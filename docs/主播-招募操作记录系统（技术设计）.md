# 招募操作记录系统（SSE 实时通知）技术设计

> 2025-10-12 更新：原基于 WebSocket 的实时通道已全面迁移为 Server-Sent Events（SSE）。本文档描述新的 SSE 架构、实现细节与运维要点。

## 1. 系统概览

招募操作记录系统负责记录所有招募相关动作（创建、编辑、面试/试播/开播决策等），并以**近实时**的方式推送给前端页面。整体目标：

- 保留完整的操作审计轨迹；
- 在招募团队之间共享最新动态，降低信息延迟；
- 通过轻量级 SSE 通道减少部署依赖，兼容常规 WSGI 环境。

### 1.1 架构示意

```
┌────────────────┐   HTTP (SSE)   ┌────────────────────────┐
│  招募前端页面   │ ◄───────────── │ /api/recruits/operations/stream │
│ (EventSource)  │                └──────────┬──────────────┘
└────────────────┘                             │(stream)
                                               ▼
                                        ┌──────────────┐
                                        │ RecruitEvent │
                                        │ StreamManager│
                                        └──────┬───────┘
                                               │ publish()
                                               ▼
                                    ┌────────────────────────┐
                                    │ record_recruit_operation │
                                    │  (持久化操作日志 + 推送) │
                                    └────────────────────────┘
```

与旧 WebSocket 方案相比：

- 无需额外的 SocketIO 依赖，完全基于 Flask + 标准库；
- SSE 为单向推送，长连接由浏览器维护，连接失败时自动重试；
- 仍保留 REST API `/api/recruits/operations` 用于首次加载历史数据。

## 2. 服务端实现

### 2.1 事件流管理器

`utils/recruit_event_stream.py` 维护一个简单的订阅列表，每个订阅者对应一个 `queue.Queue`。操作日志保存后会调用 `publish_recruit_operation_event` 广播到所有队列。

```python
# utils/recruit_event_stream.py

class RecruitEventStreamManager:
    def __init__(self):
        self._subscribers: list[queue.Queue] = []
        self._lock = threading.Lock()

    def register(self) -> queue.Queue:
        event_queue = queue.Queue(maxsize=100)
        with self._lock:
            self._subscribers.append(event_queue)
        return event_queue

    def unregister(self, event_queue: queue.Queue) -> None:
        with self._lock:
            if event_queue in self._subscribers:
                self._subscribers.remove(event_queue)

    def publish(self, payload: dict) -> None:
        serialized = json.dumps(payload, ensure_ascii=False)
        with self._lock:
            subscribers = list(self._subscribers)
        for event_queue in subscribers:
            try:
                event_queue.put_nowait(serialized)
            except queue.Full:
                logger.warning('SSE订阅队列已满，丢弃事件')

    def stream(self) -> Generator[str, None, None]:
        event_queue = self.register()
        try:
            while True:
                try:
                    message = event_queue.get(timeout=30)
                    yield f"data: {message}\n\n"
                except queue.Empty:
                    yield ": keep-alive\n\n"
        finally:
            self.unregister(event_queue)
```

公开接口：

- `recruit_operation_event_stream()`：在路由中调用，返回生成器；
- `publish_recruit_operation_event(payload)`：供业务侧广播事件。

### 2.2 事件流路由

`routes/recruits_api.py` 内新增 `/api/recruits/operations/stream`：

```python
@recruits_api_bp.route('/api/recruits/operations/stream', methods=['GET'])
@jwt_roles_accepted('gicho', 'kancho')
def stream_recruit_operations_sse():
    def generate():
        yield from recruit_operation_event_stream()

    response = Response(stream_with_context(generate()), mimetype='text/event-stream')
    response.headers['Cache-Control'] = 'no-cache'
    response.headers['X-Accel-Buffering'] = 'no'
    response.headers['Connection'] = 'keep-alive'
    return response
```

- 使用原有的 JWT Cookie 认证；
- `stream_with_context` 确保请求上下文在生成器中可用；
- 每 30 秒推送一次心跳，防止中间层关闭连接。

### 2.3 推送触发

`utils/recruit_operation_logger.record_recruit_operation` 在日志持久化后调用：

```python
operation_data = serialize_recruit_operation(operation_log)
publish_recruit_operation_event(operation_data)
```

如果广播失败会记录 warning，但不影响主流程。

## 3. 前端实现

招募列表页（`templates/recruits/list.html`）改用原生 `EventSource`：

```javascript
let eventSource = null;
let reconnectAttempts = 0;
const BASE_RECONNECT_DELAY = 3000;
const MAX_RECONNECT_DELAY = 30000;

function initEventStream() {
  cleanupEventSource();
  eventSource = new EventSource('/api/recruits/operations/stream', { withCredentials: true });

  eventSource.onopen = () => {
    updateConnectionStatus(true);
    reconnectAttempts = 0;
  };

  eventSource.onmessage = (event) => {
    if (!event.data) return;
    handleNewOperation(JSON.parse(event.data));
  };

  eventSource.onerror = (event) => {
    console.error('SSE连接错误:', event);
    updateConnectionStatus(false);
    cleanupEventSource();
    scheduleStreamReconnect();
  };
}
```

- 浏览器自动携带 JWT Cookie；
- 根据可见性变化与错误回调触发指数退避重连；
- 若连接关闭仍可依赖 REST 轮询接口作为兜底（例如刷新页面初次加载 `GET /api/recruits/operations`）。

## 4. 运维与监控

- **依赖管理**：已移除 `flask-socketio`、`eventlet`，部署仅需常规 Flask 运行环境。
- **日志**：SSE 管理器使用 `recruit_sse` logger，记录订阅数与队列溢出等信息；操作记录写入继续使用 `recruit_operation` logger。
- **连接数**：订阅列表存放在内存中（单进程模式），如需多进程扩展，可改用 Redis Pub/Sub 或消息队列共享事件。
- **安全**：SSE 接口沿用 JWT Cookie 认证，当前仅允许 `gicho`、`kancho` 角色访问；GET 请求无需 CSRF 校验。

## 5. 兼容性与扩展

- 若将来需要双向交互，可在 SSE 基础上补充轻量轮询接口，或再评估 WebSocket；
- SSE 天然支持 HTTP/2，多浏览器兼容（IE 不支持，可采用自动降级到轮询）；
- 可以拓展 `publish_recruit_operation_event`，在推送前附加更多元数据（如服务节点、延迟指标）。

## 6. 测试建议

1. **功能测试**：
   - 登录后打开两个浏览器窗口，进行招募操作，确认另一端实时收到更新；
   - 长时间无操作时，观察 SSE 心跳是否保持连接；
   - 主动断网或关闭服务，再恢复后检查重连逻辑。

2. **压力测试**：
   - 使用脚本模拟高频操作（> 50 次/分钟），确认队列不会持续溢出；
   - 多浏览器/多标签页同时订阅时，内存占用应保持线性增长。

3. **降级验证**：
   - 停止 SSE 连接（例如通过浏览器调试器 `eventSource.close()`），确认轮询接口仍可手动刷新数据。

---

至此，招募操作记录系统的实时推送逻辑已完全基于 SSE，实现部署友好、依赖精简的新方案。如需扩展其他模块的实时通知，可复用同一事件管理基础设施。
