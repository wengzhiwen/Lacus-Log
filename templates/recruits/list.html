{% extends 'base.html' %}
{% block title %}ä¸»æ’­æ‹›å‹Ÿ - Lacus-Log{% endblock %}
{% block content %}
<section class="recruits-list">
  <div class="page-header">
    <h1 class="page-title">ä¸»æ’­æ‹›å‹Ÿ</h1>
  </div>

  <div class="filter-bar">
    <button type="button" class="filter-toggle" onclick="toggleFilters()">
      <span id="filter-summary">å…¨éƒ¨æ˜¾ç¤º</span>
      <span class="toggle-icon" id="filter-toggle-icon">â–¼</span>
    </button>

    <div class="filter-form is-collapsed" id="filter-form">
      <div class="filter-row">
        <div class="filter-group">
          <label class="filter-label" for="status-filter">æ‹›å‹ŸçŠ¶æ€</label>
          <select class="filter-select" id="status-filter">
            <!-- Options will be loaded dynamically -->
          </select>
        </div>
        <div class="filter-group">
          <label class="filter-label" for="recruiter-filter">æ‹›å‹Ÿè´Ÿè´£äºº</label>
          <select class="filter-select" id="recruiter-filter">
            <!-- Options will be loaded dynamically -->
          </select>
        </div>
        <div class="filter-group">
          <label class="filter-label" for="channel-filter">æ¸ é“</label>
          <select class="filter-select" id="channel-filter">
            <!-- Options will be loaded dynamically -->
          </select>
        </div>
      </div>
    </div>
  </div>

  <div class="search-bar">
    <div class="search-input-group">
      <input type="text" id="search-input" class="search-input" placeholder="æœç´¢ä¸»æ’­æ˜µç§°æˆ–çœŸå®å§“å...">
    </div>
  </div>

  <div class="quick-nav" id="quick-nav">
    <!-- Quick nav buttons will be generated dynamically -->
  </div>

  <div class="recruit-groups" id="recruit-groups-container">
    <!-- Recruit groups will be loaded here -->
  </div>

  <div class="empty-state" id="empty-state" style="display: none;">
    <div class="empty-icon">ğŸ“‹</div>
    <div class="empty-title">æš‚æ— æ‹›å‹Ÿè®°å½•</div>
    <div class="empty-description">å½“å‰ç­›é€‰æ¡ä»¶ä¸‹æ²¡æœ‰æ‹›å‹Ÿè®°å½•ã€‚</div>
    <div class="empty-actions">
      <a class="btn btn-primary" href="{{ url_for('pilot.list_pilots') }}">å‰å¾€ä¸»æ’­ç®¡ç†</a>
    </div>
  </div>

  <button class="floating-back-to-top" id="floating-back-to-top" onclick="scrollToTop()" style="display: none;">
    â†‘
  </button>
</section>

<!-- æ‹›å‹Ÿæ“ä½œè®°å½•é¢æ¿ -->
<div class="operation-panel" id="operation-panel">
  <div class="panel-header" onclick="toggleOperationPanel()">
    <div class="panel-title">
      <span class="panel-icon">ğŸ“Š</span>
      <span class="panel-text">æ‹›å‹Ÿæ“ä½œè®°å½•</span>
      <span class="panel-status" id="panel-status">
        <span class="status-dot" id="connection-status"></span>
        <span class="connection-text" id="connection-text">è¿æ¥ä¸­...</span>
      </span>
    </div>
    <div class="panel-toggle" id="panel-toggle">
      <span id="toggle-icon">â–²</span>
    </div>
  </div>

  <div class="panel-content" id="panel-content">
    <div class="operations-list" id="operations-list">
      <!-- æ“ä½œè®°å½•å°†åœ¨è¿™é‡ŒåŠ¨æ€åŠ è½½ -->
    </div>
  </div>
</div>

<script>
// --- UTILITY FUNCTIONS ---
function toggleFilters() {
  const form = document.getElementById('filter-form');
  const icon = document.getElementById('filter-toggle-icon');
  const collapsed = form.classList.toggle('is-collapsed');
  icon.textContent = collapsed ? 'â–¼' : 'â–²';
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸä¸­å¯ç”¨
window.toggleFilters = toggleFilters;

function scrollToGroup(groupId) {
  const element = document.getElementById(groupId);
  if (element) {
    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

function scrollToTop() {
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸä¸­å¯ç”¨
window.scrollToTop = scrollToTop;

function formatDateTime(isoString) {
    if (!isoString) return '';
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) {
        return '';
    }
    const { month, day, hour, minute } = extractGmt8Parts(date);
    return `${month}æœˆ${day}æ—¥ ${hour}:${minute}`;
}

// --- CARD & GROUP CREATION ---
function createRecruitCard(recruit) {
    const isOverdue = (time) => time && new Date(time) < new Date(Date.now() - 24 * 60 * 60 * 1000);

    let timeHtml = '';
    let statusText = recruit.effective_status || 'æœªçŸ¥';
    let timeToCompare;

    switch (statusText) {
        case 'å¾…é¢è¯•':
            timeToCompare = recruit.appointment_time;
            timeHtml = `é¢„çº¦ï¼š${formatDateTime(recruit.appointment_time)}`;
            break;
        case 'å¾…é¢„çº¦è¯•æ’­':
            timeHtml = `é¢è¯•å†³ç­–ï¼š${formatDateTime(recruit.effective_interview_decision_time)}`;
            break;
        case 'å¾…è¯•æ’­':
            timeToCompare = recruit.effective_scheduled_training_time;
            timeHtml = `è¯•æ’­ï¼š${formatDateTime(recruit.effective_scheduled_training_time)}`;
            break;
        case 'å¾…é¢„çº¦å¼€æ’­':
            timeHtml = `è¯•æ’­å†³ç­–ï¼š${formatDateTime(recruit.effective_training_decision_time)}`;
            break;
        case 'å¾…å¼€æ’­':
            timeToCompare = recruit.effective_scheduled_broadcast_time;
            timeHtml = `å¼€æ’­ï¼š${formatDateTime(recruit.effective_scheduled_broadcast_time)}`;
            break;
        case 'å·²ç»“æŸ':
            timeHtml = `æœ€åä¿®æ”¹ï¼š${formatDateTime(recruit.updated_at)}`;
            break;
        default:
            timeHtml = `åˆ›å»ºäºï¼š${formatDateTime(recruit.created_at)}`;
    }

    const card = document.createElement('a');
    card.href = `/recruits/${recruit.id}`;
    card.className = 'record-card';
    card.innerHTML = `
        <div class="card-header">
            <div class="record-time">
                <div class="start-time ${isOverdue(timeToCompare) ? 'overdue' : ''}">${timeHtml}</div>
            </div>
            <div class="record-info">
                <div class="pilot-name">${recruit.pilot.nickname}</div>
                ${recruit.pilot.real_name ? `<div class="pilot-real-name">${recruit.pilot.real_name}</div>` : ''}
                <div class="meta-line">[${recruit.recruiter.nickname || recruit.recruiter.username}][${recruit.channel}]</div>
                <div class="status-line">
                    <span class="status-badge status-${statusText}">${statusText}</span>
                </div>
            </div>
        </div>
        <div class="card-footer">
            <div></div>
            <div class="card-arrow">â†’</div>
        </div>
    `;
    return card;
}

function createGroup(title, groupId, recruits) {
    if (recruits.length === 0) return null;

    const groupDiv = document.createElement('div');
    groupDiv.className = 'recruit-group';
    groupDiv.id = groupId;

    const titleEl = document.createElement('h3');
    titleEl.className = 'group-title';
    titleEl.textContent = title;
    groupDiv.appendChild(titleEl);

    const cardsContainer = document.createElement('div');
    cardsContainer.className = 'record-cards';
    recruits.forEach(recruit => {
        cardsContainer.appendChild(createRecruitCard(recruit));
    });
    groupDiv.appendChild(cardsContainer);

    return groupDiv;
}

// --- DATA RENDERING & FILTERING ---

function renderRecruits(recruits) {
    const container = document.getElementById('recruit-groups-container');
    const quickNav = document.getElementById('quick-nav');
    const emptyState = document.getElementById('empty-state');
    container.innerHTML = '';
    quickNav.innerHTML = '';

    const groupMapping = {
        pending_interview: 'å¾…é¢è¯•',
        pending_training_schedule: 'å¾…é¢„çº¦è¯•æ’­',
        pending_training: 'å¾…è¯•æ’­',
        pending_broadcast_schedule: 'å¾…é¢„çº¦å¼€æ’­',
        pending_broadcast: 'å¾…å¼€æ’­',
        overdue: 'é¸½',
        ended: 'å·²ç»“æŸ'
    };

    let totalRecruits = 0;
    for (const key in groupMapping) {
        const groupData = recruits[key] || [];
        totalRecruits += groupData.length;
        const groupElement = createGroup(groupMapping[key], key, groupData);
        if (groupElement) {
            container.appendChild(groupElement);
            const navButton = document.createElement('button');
            navButton.className = 'quick-nav-btn';
            navButton.textContent = groupMapping[key];
            navButton.onclick = () => scrollToGroup(key);
            quickNav.appendChild(navButton);
        }
    }

    if (totalRecruits === 0) {
        emptyState.style.display = 'block';
    } else {
        emptyState.style.display = 'none';
    }
}

// å­˜å‚¨æ‰€æœ‰æ‹›å‹Ÿæ•°æ®ï¼Œç”¨äºå‰ç«¯æœç´¢
let allRecruitsData = [];

async function fetchAndRenderRecruits() {
    try {
        const status = document.getElementById('status-filter').value;
        const recruiterId = document.getElementById('recruiter-filter').value;
        const channel = document.getElementById('channel-filter').value;

        const payload = await RecruitAPI.getRecruits({
            status: status,
            recruiter_id: recruiterId,
            channel: channel,
            page_size: 500 // Fetch a large number for client-side grouping
        });
        
        allRecruitsData = payload.data.items;
        
        // åº”ç”¨å‰ç«¯æœç´¢è¿‡æ»¤
        const searchTerm = document.getElementById('search-input').value;
        const filteredRecruits = applySearchFilter(allRecruitsData, searchTerm);

        if (status === 'é¸½') {
            renderRecruits({ overdue: filteredRecruits });
        } else if (status === 'å·²ç»“æŸ') {
            renderRecruits({ ended: filteredRecruits });
        } else { // "è¿›è¡Œä¸­"
            groupAndRender(filteredRecruits);
        }

    } catch (error) {
        console.error('Failed to load recruits:', error);
        document.getElementById('empty-state').style.display = 'block';
    }
}

function applySearchFilter(recruits, searchTerm) {
    if (!searchTerm || searchTerm.trim() === '') {
        return recruits;
    }
    
    const keyword = searchTerm.trim().toLowerCase();
    return recruits.filter(recruit => {
        const nickname = (recruit.pilot?.nickname || '').toLowerCase();
        const realName = (recruit.pilot?.real_name || '').toLowerCase();
        return nickname.includes(keyword) || realName.includes(keyword);
    });
}

function performClientSideSearch() {
    if (allRecruitsData.length === 0) {
        return; // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œä¸æ‰§è¡Œæœç´¢
    }
    
    const status = document.getElementById('status-filter').value;
    const searchTerm = document.getElementById('search-input').value;
    const filteredRecruits = applySearchFilter(allRecruitsData, searchTerm);

    if (status === 'é¸½') {
        renderRecruits({ overdue: filteredRecruits });
    } else if (status === 'å·²ç»“æŸ') {
        renderRecruits({ ended: filteredRecruits });
    } else { // "è¿›è¡Œä¸­"
        groupAndRender(filteredRecruits);
    }
}

function groupAndRender(recruits) {
    const grouped = {
        pending_interview: [],
        pending_training_schedule: [],
        pending_training: [],
        pending_broadcast_schedule: [],
        pending_broadcast: [],
        overdue: [], // This needs to be calculated based on time, API doesn't provide it directly
        ended: []
    };

    recruits.forEach(r => {
        const status = r.effective_status;
        switch(status) {
            case 'å¾…é¢è¯•': grouped.pending_interview.push(r); break;
            case 'å¾…é¢„çº¦è¯•æ’­': grouped.pending_training_schedule.push(r); break;
            case 'å¾…è¯•æ’­': grouped.pending_training.push(r); break;
            case 'å¾…é¢„çº¦å¼€æ’­': grouped.pending_broadcast_schedule.push(r); break;
            case 'å¾…å¼€æ’­': grouped.pending_broadcast.push(r); break;
            case 'å·²ç»“æŸ': grouped.ended.push(r); break;
        }
    });

    renderRecruits(grouped);
}


async function populateFilters() {
    try {
        const payload = await RecruitAPI.getOptions();
        const { enums, recruiter_choices } = payload.data;

        const statusFilter = document.getElementById('status-filter');
        statusFilter.innerHTML = `
            <option value="è¿›è¡Œä¸­">è¿›è¡Œä¸­</option>
            <option value="é¸½">é¸½</option>
            <option value="å·²ç»“æŸ">å·²ç»“æŸ</option>
        `;
        statusFilter.value = 'è¿›è¡Œä¸­'; // Set default

        const recruiterFilter = document.getElementById('recruiter-filter');
        recruiterFilter.innerHTML = '<option value="">å…¨éƒ¨è´Ÿè´£äºº</option>';
        recruiter_choices.forEach(choice => {
            const option = new Option(choice.label, choice.value);
            recruiterFilter.add(option);
        });

        const channelFilter = document.getElementById('channel-filter');
        channelFilter.innerHTML = '<option value="">å…¨éƒ¨æ¸ é“</option>';
        Object.keys(enums.channel).forEach(key => {
            const option = new Option(enums.channel[key], key);
            channelFilter.add(option);
        });

    } catch (error) {
        console.error('Failed to populate filters:', error);
    }
}


// --- OPERATION PANEL & EVENT STREAM ---
let eventSource = null;
let panelExpanded = false;
let operationsData = [];
let reconnectAttempts = 0;
let reconnectTimer = null;
const BASE_RECONNECT_DELAY = 3000;
const MAX_RECONNECT_DELAY = 30000;
const gmt8Formatter = new Intl.DateTimeFormat('zh-CN', {
    timeZone: 'Asia/Shanghai',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
});

function extractGmt8Parts(date) {
    const parts = gmt8Formatter.formatToParts(date);
    const lookup = {};
    parts.forEach((part) => {
        lookup[part.type] = part.value;
    });
    return {
        month: lookup.month || '00',
        day: lookup.day || '00',
        hour: lookup.hour || '00',
        minute: lookup.minute || '00'
    };
}

function cleanupEventSource() {
    if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
    }

    if (!eventSource) {
        return;
    }

    try {
        eventSource.close();
    } catch (closeError) {
        console.warn('å…³é—­SSEè¿æ¥å¤±è´¥:', closeError);
    }

    eventSource = null;
}

function scheduleStreamReconnect({ immediate = false } = {}) {
    if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
    }

    if (immediate) {
        reconnectAttempts = 0;
        initEventStream();
        return;
    }

    reconnectAttempts = Math.min(reconnectAttempts + 1, 6);
    const delay = Math.min(BASE_RECONNECT_DELAY * (2 ** (reconnectAttempts - 1)), MAX_RECONNECT_DELAY);
    console.warn(`SSEè¿æ¥å°†åœ¨${delay}msåé‡è¯•ï¼Œç¬¬${reconnectAttempts}æ¬¡å°è¯•`);

    reconnectTimer = setTimeout(() => {
        initEventStream();
    }, delay);
}

// åˆ‡æ¢æ“ä½œé¢æ¿å±•å¼€/æŠ˜å çŠ¶æ€
function toggleOperationPanel() {
    const panel = document.getElementById('operation-panel');
    const toggle = document.getElementById('toggle-icon');

    panelExpanded = !panelExpanded;

    if (panelExpanded) {
        panel.classList.remove('collapsed');
        toggle.textContent = 'â–²';
        // å±•å¼€æ—¶åŠ è½½æ›´å¤šæ“ä½œè®°å½•
        loadMoreOperations();
    } else {
        panel.classList.add('collapsed');
        toggle.textContent = 'â–¼';
        // æŠ˜å æ—¶åªæ˜¾ç¤º1æ¡è®°å½•
        renderOperations(1);
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸä¸­å¯ç”¨
window.toggleOperationPanel = toggleOperationPanel;

// æ ¼å¼åŒ–æ“ä½œæ—¶é—´
function formatOperationTime(operation) {
    if (!operation) return '';

    const candidates = [operation.operation_time_gmt8_iso, operation.operation_time_utc];

    for (const iso of candidates) {
        if (!iso) continue;
        const date = new Date(iso);
        if (!Number.isNaN(date.getTime())) {
            const { month, day, hour, minute } = extractGmt8Parts(date);
            return `${month}-${day} ${hour}:${minute}`;
        }
    }

    if (operation.operation_time_gmt8) {
        return operation.operation_time_gmt8;
    }

    return '';
}

// æ¸²æŸ“æ“ä½œè®°å½•åˆ—è¡¨
function renderOperations(limit = 10) {
    const list = document.getElementById('operations-list');
    const operationsToShow = operationsData.slice(0, limit);

    if (operationsToShow.length === 0) {
        list.innerHTML = '<div class="operation-empty">æš‚æ— æ“ä½œè®°å½•</div>';
        return;
    }

    list.innerHTML = operationsToShow.map(op => `
        <div class="operation-item">
            <div class="operation-time">${formatOperationTime(op)}</div>
            <div class="operation-user">${op.user_nickname || 'æœªçŸ¥ç”¨æˆ·'}</div>
            <div class="operation-type">${op.operation_type}</div>
            <div class="operation-pilot">${op.pilot_nickname || 'æœªçŸ¥ä¸»æ’­'}</div>
        </div>
    `).join('');
}

// åŠ è½½æ›´å¤šæ“ä½œè®°å½•
async function loadMoreOperations() {
    try {
        const response = await fetch('/api/recruits/operations?limit=10', {
            method: 'GET',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (response.ok) {
            const payload = await response.json();
            if (payload.success) {
                operationsData = payload.data || [];
                renderOperations(panelExpanded ? 10 : 1);
            }
        }
    } catch (error) {
        console.error('åŠ è½½æ“ä½œè®°å½•å¤±è´¥:', error);
    }
}

// åˆå§‹åŒ–äº‹ä»¶æµï¼ˆSSEï¼‰
function initEventStream() {
    cleanupEventSource();

    try {
        eventSource = new EventSource('/api/recruits/operations/stream', { withCredentials: true });
    } catch (error) {
        console.error('åˆ›å»ºSSEè¿æ¥å¤±è´¥:', error);
        scheduleStreamReconnect();
        return;
    }

    eventSource.onopen = () => {
        console.log('SSEè¿æ¥å·²å»ºç«‹');
        updateConnectionStatus(true);
        reconnectAttempts = 0;
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            reconnectTimer = null;
        }
    };

    eventSource.onmessage = (event) => {
        if (!event.data) {
            return;
        }

        try {
            const payload = JSON.parse(event.data);
            handleNewOperation(payload);
        } catch (parseError) {
            console.error('è§£æSSEæ¶ˆæ¯å¤±è´¥:', parseError, event.data);
        }
    };

    eventSource.onerror = (event) => {
        console.error('SSEè¿æ¥é”™è¯¯:', event);
        updateConnectionStatus(false);
        cleanupEventSource();
        scheduleStreamReconnect();
    };
}

// å¤„ç†æ–°çš„æ“ä½œè®°å½•
function handleNewOperation(operation) {
    // å°†æ–°æ“ä½œæ·»åŠ åˆ°åˆ—è¡¨å¼€å¤´
    operationsData.unshift(operation);

    // é™åˆ¶åˆ—è¡¨é•¿åº¦
    if (operationsData.length > 50) {
        operationsData = operationsData.slice(0, 50);
    }

    // é‡æ–°æ¸²æŸ“åˆ—è¡¨
    renderOperations(panelExpanded ? 10 : 1);

    // å¦‚æœé¢æ¿æ˜¯æŠ˜å çš„ï¼ŒçŸ­æš‚å±•å¼€æ˜¾ç¤ºæ–°æ“ä½œ
    if (!panelExpanded) {
        const panel = document.getElementById('operation-panel');
        panel.classList.add('highlight');
        setTimeout(() => {
            panel.classList.remove('highlight');
        }, 2000);
    }
}

// æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
function updateConnectionStatus(connected) {
    const statusDot = document.getElementById('connection-status');
    const statusText = document.getElementById('connection-text');

    if (connected) {
        statusDot.className = 'status-dot connected';
        statusText.textContent = 'å·²è¿æ¥';
    } else {
        statusDot.className = 'status-dot disconnected';
        statusText.textContent = 'è¿æ¥ä¸­...';
    }
}

// é¡µé¢å¯è§æ€§å˜åŒ–æ—¶çš„å¤„ç†
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        return;
    }

    if (!eventSource || eventSource.readyState === EventSource.CLOSED) {
        scheduleStreamReconnect({ immediate: true });
        return;
    }

    if (eventSource.readyState === EventSource.OPEN) {
        loadMoreOperations();
    }
});

// --- EVENT LISTENERS & INITIALIZATION ---
document.addEventListener('DOMContentLoaded', function () {
    populateFilters().then(() => {
        fetchAndRenderRecruits();
    });

    document.getElementById('status-filter').addEventListener('change', fetchAndRenderRecruits);
    document.getElementById('recruiter-filter').addEventListener('change', fetchAndRenderRecruits);
    document.getElementById('channel-filter').addEventListener('change', fetchAndRenderRecruits);

    let searchTimeout;
    document.getElementById('search-input').addEventListener('input', () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(performClientSideSearch, 300); // Debounce search
    });

    const floatingBtn = document.getElementById('floating-back-to-top');
    window.addEventListener('scroll', () => {
        if (window.pageYOffset > 300) {
            floatingBtn.style.display = 'block';
        } else {
            floatingBtn.style.display = 'none';
        }
    });

    // åˆå§‹åŒ–æ“ä½œé¢æ¿
    const panel = document.getElementById('operation-panel');
    panel.classList.add('collapsed');
    document.getElementById('toggle-icon').textContent = 'â–¼';

    // åˆå§‹åŒ–SSEè¿æ¥
    initEventStream();

    // åŠ è½½åˆå§‹æ“ä½œè®°å½•
    loadMoreOperations();

    window.addEventListener('beforeunload', cleanupEventSource);
});
</script>

<style>
.filter-toggle {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--brand);
  color: #fff;
  border: none;
  border-radius: 8px;
  padding: 12px 14px;
  margin-bottom: 10px;
  font-size: 14px;
}

.filter-form.is-collapsed { display: none; }
.filter-form { margin-bottom: 12px; }

.filter-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; }
.filter-group { margin-bottom: 8px; }
.filter-label { font-size: 14px; color: var(--text); display: block; margin-bottom: 4px; }
.filter-select { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid var(--table-header); background: #fff; }

.search-bar { margin-bottom: 16px; }
.search-input-group { display: flex; }
.search-input {
  width: 100%;
  border: 1px solid var(--table-header);
  padding: 10px 12px;
  font-size: 14px;
  border-radius: 8px;
  outline: none;
}

.quick-nav {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 20px;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 8px;
  border: 1px solid var(--table-header);
}

.quick-nav-btn {
  padding: 6px 12px;
  background: #fff;
  border: 1px solid var(--table-header);
  border-radius: 6px;
  font-size: 12px;
  color: var(--text);
  cursor: pointer;
}
.quick-nav-btn:hover { background: var(--brand); color: #fff; }

.recruit-groups { margin-bottom: 20px; }
.recruit-group { margin-bottom: 24px; }
.group-title {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 2px solid var(--brand);
}

.record-cards { display: block; }
.record-card {
  display: block;
  background: #fff;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 12px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  border: 1px solid var(--table-header);
  text-decoration: none;
  color: inherit;
  transition: all 0.2s ease;
}
.record-card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  transform: translateY(-2px);
  border-color: var(--brand);
}
.card-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
.record-time { flex: 0 0 auto; }
.start-time { font-size: 16px; font-weight: 600; }
.start-time.overdue { color: #d32f2f; }
.record-info { flex: 1; text-align: right; }
.pilot-name { font-size: 14px; font-weight: 500; }
.pilot-real-name { font-size: 12px; color: var(--muted); }
.meta-line { font-size: 12px; color: var(--muted); }
.status-line { margin-top: 4px; }
.status-badge { padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 500; }
.status-å¾…é¢è¯• { background: #e3f2fd; color: #1565c0; }
.status-å¾…é¢„çº¦è¯•æ’­ { background: #f3e5f5; color: #7b1fa2; }
.status-å¾…è¯•æ’­ { background: #fff3e0; color: #ef6c00; }
.status-å¾…é¢„çº¦å¼€æ’­ { background: #e8f5e8; color: #2e7d32; }
.status-å¾…å¼€æ’­ { background: #fff8e1; color: #f57c00; }
.status-é¸½ { background: #ffebee; color: #d32f2f; }
.status-å·²ç»“æŸ { background: #eceff1; color: #546e7a; }
.card-footer { display: flex; align-items: center; justify-content: space-between; border-top: 1px solid var(--table-header); padding-top: 8px; margin-top: 8px; }
.card-arrow { color: var(--muted); }
.record-card:hover .card-arrow { color: var(--brand); }

.floating-back-to-top {
  position: fixed; bottom: 20px; right: 20px;
  width: 48px; height: 48px;
  background: var(--brand); color: #fff;
  border: none; border-radius: 50%;
  font-size: 20px; cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.empty-state { text-align: center; padding: 60px 20px; }
.empty-icon { font-size: 48px; margin-bottom: 16px; }
.empty-title { font-size: 18px; font-weight: 600; }
.empty-description { color: var(--muted); margin-bottom: 24px; }

/* æ‹›å‹Ÿæ“ä½œè®°å½•é¢æ¿ */
.operation-panel {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: #fff;
  border-top: 2px solid var(--table-header);
  box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
  z-index: 1000;
  transition: all 0.3s ease;
  max-height: 50vh;
}

.operation-panel.collapsed {
  max-height: 140px;
}

.operation-panel.highlight {
  border-top-color: var(--brand);
  box-shadow: 0 -2px 15px rgba(0,0,0,0.2);
}

.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: #f8f9fa;
  border-bottom: 1px solid var(--table-header);
  cursor: pointer;
  user-select: none;
}

.panel-title {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
}

.panel-icon {
  font-size: 16px;
}

.panel-text {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
}

.panel-status {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-right: 12px;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #ccc;
}

.status-dot.connected {
  background: #4caf50;
  animation: pulse 2s infinite;
}

.status-dot.disconnected {
  background: #f44336;
}

.connection-text {
  font-size: 12px;
  color: var(--muted);
}

.panel-toggle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  color: var(--muted);
  transition: transform 0.3s ease;
}

.operation-panel.collapsed .panel-toggle {
  transform: rotate(180deg);
}

.panel-content {
  overflow-y: auto;
  max-height: calc(50vh - 60px);
  transition: all 0.3s ease;
}

.operation-panel.collapsed .panel-content {
  max-height: 80px;
  overflow: hidden;
}

.operations-list {
  padding: 0;
}

.operation-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid var(--table-header);
  font-size: 13px;
  transition: background-color 0.2s ease;
}

.operation-item:hover {
  background: #f8f9fa;
}

.operation-item:last-child {
  border-bottom: none;
}

.operation-time {
  flex: 0 0 120px;
  color: var(--muted);
  font-size: 12px;
}

.operation-user {
  flex: 0 0 80px;
  color: var(--text);
  font-weight: 500;
  text-align: center;
}

.operation-type {
  flex: 0 0 80px;
  color: var(--brand);
  font-weight: 500;
  text-align: center;
}

.operation-pilot {
  flex: 1;
  color: var(--text);
  text-align: right;
}

.operation-empty {
  text-align: center;
  padding: 40px 20px;
  color: var(--muted);
  font-size: 14px;
}

.loading-spinner {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
  color: var(--muted);
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid var(--table-header);
  border-top: 2px solid var(--brand);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 8px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
  }
}

/* ç§»åŠ¨ç«¯é€‚é… */
@media (max-width: 768px) {
  .operation-panel {
    max-height: 60vh;
  }

  .operation-item {
    padding: 10px 12px;
    font-size: 12px;
  }

  .operation-time {
    flex: 0 0 100px;
  }

  .operation-user {
    flex: 0 0 70px;
  }

  .operation-type {
    flex: 0 0 70px;
  }

  .panel-title {
    gap: 6px;
  }

  .panel-icon {
    font-size: 14px;
  }

  .panel-text {
    font-size: 13px;
  }
}
</style>
{% endblock %}
