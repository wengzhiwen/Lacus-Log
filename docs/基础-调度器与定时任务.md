# 基础-调度器与定时任务

> 术语统一记录（2025-09-26）
> - 历史用语→统一用语：征召→招募；作战计划→通告；作战记录→开播记录。
> - 本次复核（2025-09-26）：已完成逐段术语检查，正文采用统一用语；数据库/接口字段仍保留历史命名，仅以字段标注说明。
本文件描述应用内置调度器的整体设计与实现约定，涵盖 APScheduler 集成、任务防重策略（JobPlan 令牌）、环境开关、时间口径与日志规范。

---

## 设计目标
- 在不依赖系统级 cron 的前提下，提供可靠的“应用内置定时调度”。
- 支持单机多进程/生产多实例部署下的“同计划只执行一次”。
- 统一时间口径：数据库 UTC 存储；调度以 UTC 触发；UI 按 GMT+8 展示。
- 易于扩展与维护，最小侵入地集成到现有 Flask 应用。

---

## 组件与文件
- `utils/scheduler.py`：APScheduler 初始化与任务注册入口（后台线程方式）。
- `utils/job_token.py`：MongoDB 任务计划令牌（JobPlan）工具，提供 `plan_fire()` 与 `consume_fire()`。
- `app.py`：应用工厂在注册完蓝图与安全组件后，根据环境开关选择性启动调度器。

---

## 启动流程
1. 应用完成日志、数据库、蓝图、安全组件等初始化。
2. 读取环境变量 `ENABLE_SCHEDULER`：
   - `true` 启用；否则跳过并记录日志。
3. 开发环境（带自动重载）仅在“重载主进程”启动调度器：
   - 通过 `WERKZEUG_RUN_MAIN == 'true'` 判定，避免重复注册任务。
4. 调度器启动前，尝试清空历史 JobPlan（仅应用启动处执行一次，避免重启冲突）。
5. 初始化并启动 APScheduler（UTC 时区），注册各 Cron 任务。

---

## 任务注册与时间触发
- 使用 `CronTrigger` 明确调度的 UTC 触发时间：
  - 未开播提醒：UTC 12:00（等效 GMT+8 20:00）。
  - 开播日报自动邮件：UTC 07:00（等效 GMT+8 15:00，发送前一自然日数据）。
  - 开播月报自动邮件：UTC 07:02（等效 GMT+8 15:02，发送前一自然日所在月数据）。
  - 招募日报：UTC 16:05（等效 GMT+8 00:05，发送前一自然日数据）。
- 工具函数 `_next_fire_utc(trigger)` 用于计算"下一次触发时间"（UTC，tz-aware）。

---

## 防重策略：JobPlan 令牌
- 目标：在多进程/多实例环境下，保证“同一计划时间点（分钟精度）”仅执行一次。
- 核心集合：`job_plans`
  - 复合唯一键：`job_code + fire_minute`（UTC，格式 `YYYYMMDDHHMM`）。
  - TTL 索引：`expire_at`，`expireAfterSeconds = 7 * 24 * 3600`。
- 工作流：
  1) 启动时：依据 Cron 计算“下一次触发 UTC 分钟”，调用 `plan_fire(job_code, fire_dt_utc)` 写入/刷新计划（幂等 upsert）。
  2) 触发时：以“当前 UTC 分钟”调用 `consume_fire(job_code, fire_dt_utc)` 原子消费；若返回 True 才执行任务，否则说明该分钟计划不存在（被他处消费或未规划），直接跳过。
  3) 任务完成后：再写入下一次计划（使用 `_next_fire_utc()` 计算）。
- 重要约定：
  - 令牌的时间粒度为“分钟”，任务包装器中需将 `second/microsecond` 归零。
  - 所有时间均为 tz-aware 的 UTC 时间；禁止 naive datetime。

---

## 环境与部署约定
- `ENABLE_SCHEDULER`：是否启用内置调度器（默认不启用）。
- 开发环境自动重载：仅在重载主进程实例启动调度器，避免本地重复触发。
- 生产多实例部署：建议仅在“领导实例（leader）”启用该开关；或借助外部选主机制确保单实例执行。

---

## 日志规范
- 模块日志名：`scheduler`，输出到 `log/scheduler.log`（按自然日切分）。
- 关键日志：
  - 启动：索引确保、任务数。
  - 计划：写入下一次计划失败需记录 `ERROR`。
  - 触发：当 `consume_fire` 返回 False，应记录 `INFO` 说明“跳过执行（计划令牌不存在）”。
  - 执行：任务完成记录摘要信息（例如发送结果、统计数量等）。
- 第三方库日志：若量大，应显式设为 `INFO`。

---

## 现有内置任务
- `daily_unstarted_report`（未开播提醒）
  - 触发：每日 GMT+8 20:00（UTC 12:00）
  - 行为：调用 `routes.report_mail.run_unstarted_report_job()`，有数据则邮件发送，无数据仅记录 INFO。
- `daily_report`（开播日报自动邮件）
  - 触发：每日 GMT+8 15:00（UTC 07:00）
  - 行为：调用 `routes.report_mail.run_daily_report_job()` 发送前一自然日的开播日报概要。
- `daily_monthly_mail_report`（开播月报自动邮件）
  - 触发：每日 GMT+8 15:02（UTC 07:02）
  - 行为：调用 `routes.report_mail.run_monthly_mail_report_job()` 发送前一自然日所在月的开播月报概要。
- `daily_recruit_daily_report`（招募日报）
  - 触发：每日 GMT+8 00:05（UTC 16:05 of previous day）
  - 行为：调用 `routes.report_mail.run_recruit_daily_report_job()` 发送前一自然日的招募日报。

---

## 时间口径
- 存储与调度均以 UTC 为准；UI 输入与展示按 GMT+8。
- 招募日报“前一自然日”的定义基于 GMT+8 的本地日期归属后再换算到 UTC 范围。

---

## 扩展任务的建议实践
- 定义独立的 `job_code`，并以分钟为粒度规划触发时间。
- 在任务包装器内：
  1) 计算 `fire_dt_utc = now_utc.replace(second=0, microsecond=0)`。
  2) `if not consume_fire(job_code, fire_dt_utc): return`。
  3) 创建 `app_context()` 执行业务逻辑。
  4) `plan_fire(job_code, _next_fire_utc(trigger))`。
- 遇到异常：记录 `ERROR`，必要时在业务层实现幂等与补偿。
